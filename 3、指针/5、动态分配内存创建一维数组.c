#include <stdio.h>
#include <malloc.h>

/* 
  利用动态分配内存，创建一维数组
  动态分配内存空间，实际上会在返回的地址前后分配额外的内存，用于记录申请空间的大小等元信息
  如果越界访问改写了额外的内存，free()是会出错的，因为free就依赖这里的信息。
  具体看note

  

*/
void main()
{
  double *arr = (double *)malloc(24);//实际上您可以将 malloc 的结果存储到任何指针变量中而不进行强制转换，因为 ISO c 在必要时会自动将 void * 类型转换为另一种类型的指针
  //如果我将动态内存分配的大小修改为30 那么因为内存对齐，所以没有造成越界，如果是24的话 i大于3 就会越界。
  //Malloc 提供给您的块保证是对齐的，这样它就可以保存任何类型的数据。在 GNU 系统中，32位系统地址总是上8的倍数的块，64位系统上是16的倍数的块。
// 也就是说系统会根据我们请求分配的块来决定是否以及如何对齐，所以实际上返回的内存块有可能是会比我们请求的大，因为系统为了对齐进行了操作。《深入理解计算机系统》P878
// 所以就能够解释，为什么有些时候越界操作，不会报错，而有些时候就会报错。
  for (int i = 0; i < 4; i++)
  {
    arr[i] = i + 1;
    printf("%f\n", arr[i]);
  }
  //printf("%d \n", sizeof(*arr));//因为返回值为首个存储单元的地址，并且创建的是double类型的，所以长度为8
  free(arr);
  
  getchar();
}