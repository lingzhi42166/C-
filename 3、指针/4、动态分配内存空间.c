#include <stdio.h>
#include <malloc.h>
/* 
  传统数组的缺点:
    1、如没有初始化值，那么就必须在声明的时候给定长度，且只能是常整数，不能是变量
    一旦定义了长度，就不能更改，也就是在运行的过程中数组的长度不能动态扩充和缩小
    2、数组所占用的内存空间无法手动释放

  动态分配内存:
    通过动态分配内存就可以解决传统数组的这些缺点
    通过 malloc() 实现动态分配内存
    需要引入malloc.h头文件
    如:
      (int *)malloc(4) 
        参数只能有一个，并且是整型。
        该语句的作用:
          分配一个大小为4个字节的整型数据类型的空间
        返回值为起始地址
        通过free() 释放内存空间
    为什么需要(int *)
      因为malloc的原型是 void * malloc()
      即该函数是一个指针型函数，返回的是该分配域的起始位置。
      在低版本中，int *类型的指针变量，不能赋值void *类型的，所以需要 (int *) 强制转换malloc类型
      在高版本中，是自动转换的。


    四个动态分配内存的函数
      需要引入<stdlib.h>
        1、函数原型:void *malloc(size)
          动态分配一个size大小的连续空间，返回首地址分配不成功返回NULL
        2、函数原型:void *calloc(n,size)
          动态分配 n 个 size大小的连续空间，返回起始地址，分配不成功返回NULL
        3、函数原型:void free(void *p) 
          释放动态内存空间
        4、函数原型:void *realloc(void *p,size)
          重新分配动态空间的大小，分配失败返回NULL
*/
void main()
{
  int *p = (int *)malloc(4); //动态分配了4个字节大小的整型数据类型空间,并把地址开头存储在了p指针变量中。
  int i = 6;

  printf("%p\n", p);  //p 就是动态分配的内存存储单元地址的开头
  printf("%d\n", *p); //创建动态内存时，系统随机分配的垃圾值

  *p = i;
  printf("%d\n", *p); //6

  //
  free(p); //释放内存
  printf("%p\n", p);
  printf("%d\n", *p); //此时p所指向的地址 已经被释放了，所以*p 不再是6
  getchar();
}
